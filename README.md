# options-pricing
Pricing vanilla European and American options using numerical methods.

Project completed for the Programming for Quant Finance module at the University of Warwick (MSc Mathematical Finance).

The aim of this project was to develop a C++ program that can price vanilla European and American options using the Cox-Ross-Rubinstein (CRR) model. The model was implemented using two different algorithms (forward-recursion and backward-induction).

## Implementation Details
The traditional waterfall methodology was used. As such, the project was broken down into phases, which were completed one after the other. Typically, the first phase of the waterfall approach is the specification of the software requirements. In this project, the requirements were laid out in the brief. The second and third phases are the design of the software architecture and the implementation itself.

The first step of the CRR method is to calculate the exercise value, or payoff, of the option at each of the tree’s base nodes. As the payoff function is different for call and put options, each has their own derived class. The 'OptionValueCalculator' base class includes common features, such as a strike price, to avoid repetition. When instantiating an object, the derived classes’ constructors delegate to the base constructor, which stores the strike argument in a member variable. The advantage of this class structure is that it is flexible – derived classes can be created for other types of option. To calculate the exercise value, the pure virtual member function 'calculate' is used. The base class, which is now abstract, cannot have an implementation of 'calculate' because it does not have a payoff function. Each derived class has its own implementation, in which the strike price is read by a const member function. This conforms to the message-passing paradigm and maintains encapsulation, as the strike cannot be modified outside of the base class. 

The 'BinomialOptionPricer' class implements two algorithms that calculate the option’s value at the other nodes in the tree. The first is forward-recursion. To keep track of i (the time step) and j (the number of previous 'up' moves), function overloading is used, i.e. the forward-recursion functions each call a recursive function with the same name and two additional arguments, i and j. The second algorithm is backward-induction. The exercise values at the base nodes are stored in a dynamically allocated array and are continually replaced as the algorithm moves back through the tree. The length of the array is not a compile-time constant – it has to be one more than the object’s maximum depth to ensure that there’s always enough space. The memory is allocated in the constructor and deleted in the destructor (to avoid memory leaks). As a result, the implementation conforms to resource acquisition is initialization (RAII). Furthermore, a non-default copy-constructor and copy-assignment operator are included because of the 'rule of three'. 

It is sensible to include a check on the requested depth to stop the algorithm running for an excessively long time. In this case, using exceptions is more appropriate than branching because the input is incorrect. Therefore, try blocks are included in each of the pricing functions. If the depth exceeds the maximum depth, an exception is raised. A catch block then prints an error message and returns -1, the thrown integer. A negative number ensures that the output is not confused with a price.

The fourth stage of the waterfall model is testing. There were several requirements that had to be tested. Firstly, the two algorithms had to produce the same output. Secondly, the numerical solution for European options had to converge to the Black-Scholes solution. Finally, the prices of American options had to be at least as large as those of European options (within machine precision). This is because of their additional time value. To check these conditions, test functions were created. To keep the code organised, all test functions were combined in a 'PricingTest' class. To improve the code’s readability, the Black-Scholes prices are calculated by separate functions, 'BS call()' or 'BS put()'. Another function, 'test copy()', was created to test the copy-constructor and copy-assignment operator.

## Algorithmic Analysis
Graph showing the time taken to price 100 vanilla options using the forward-recursion and backward-induction
algorithms:

![complexity2](https://user-images.githubusercontent.com/69372349/163238330-fee2cbb1-f665-434a-9d7e-3b8b03d530f3.png)

It is clear that the time taken to run both algorithms increases with depth. This is because the option’s value has to be calculated at a greater number of nodes. Backward-induction is fastest. In fact, quadratic trendlines can be fit very closely to both the European and American curves, indicating that the time complexity of backward-induction is O(n^2). This makes sense because the number of calculations needed to move back a time step is equal to the height of the tree. For example, to move from the third time step to the second time step, three calculations are required. Therefore, if there
are n intervals, n + (n − 1) + ... + 1 = n(n + 1)/2 calculations are needed. The dominant power in this expression is n^2. Note that n+1 exercise values are calculated. This is of a smaller order and thus does not affect the time complexity, which focuses on the algorithm’s asymptotic behaviour. 

Forward-recursion scales poorly with depth for both European and American options – the runtime approximately doubles for each additional time step. It follows that the time complexity is O(2^n), which represents the worst-case scenario for the CRR model. This makes sense because there are two recursive calls at each node. Thus, if the depth is increased by one, twice as many exercise values need to be calculated at the base of the tree. Forward-recursion is effectively using a non-recombinant tree, which grows exponentially with depth. 

Tail recursion is not possible because the outputs from two recursive calls have to be added together in each return statement. Therefore, the function’s stack frame has to be stored and cannot be re-used. The total number of stored stack frames approximately doubles for each additional time interval. Hence, one would expect forward-recursion to have an exponential space complexity. Backward-induction, on the other hand, has lower memory requirements. This is because the length of the dynamically allocated array is invariant with depth – it depends only on the maximum depth. 

The graph above also shows that runtimes are higher for American options. This is because the exercise value needs to be calculated at each node, and thus the number of operations at each inductive step increases. That being said, the layout of the tree is the same as for European options. Therefore, the time complexity remains of order n^2.
